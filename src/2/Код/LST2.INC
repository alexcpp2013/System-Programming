;                     ‹€‘’€Ќѓ 2.2
;      Џа®жҐ¤гал ўў®¤ /ўлў®¤  ®ЎйҐЈ® ­ §­ зҐ­Ёп
;       ¤«п а Ў®вл ў жўҐв­®¬ вҐЄбв®ў®¬ аҐ¦Ё¬Ґ
;
; Ђўв®а вҐЄбв  Їа®Ја ¬¬л Љг« Є®ў ‚« ¤Ё¬Ёа ѓҐ­­ ¤мҐўЁз.
; ” ©« lst_2_02.inc, 10.03.2000.

DATASEG
; Колір і фон тексту, що виводиться (за замовчуванням встановимо
; вивід білого тексту по чорному фону)
TextColorAndBackground DB 0Fh
; Початкова позиція для виводу текстової строки на екран 
ScreenString DW ?
ScreenColumn DW ?
ENDS

CODESEG
;*******************************************************
;*    Вивід байта на екран в шістнадцятирічному коді   *
;* Підпрограма виводить вміст регістру AL              *
;* в шіснадцятирічному коді в задану позицію екрана.   *
;* Координати позиції передаються через глобальні      *
;* змінні ScreenString і ScreenColumn. Після           *
;* виконання операції виводу відбувається автомати-    *
;* чне збільшення значень цих змінних.                 *
;*******************************************************
PROC ShowByteHexCode near
        pusha
        push    DS
        push    ES
        ; Настроїти DS на глобальний сегмент даних
        mov     DI,DGROUP
        mov     DS,DI
        ; Настроїти строкові команди процесора на 
        ; автоінкрементний режим (рух "вперед")
        cld

; Настроїти пару ES:DS для прямого виводу у відеопам'ять
        push    AX
        ; Завантажити адресу сегмента відеоданих в ES
        mov     AX,0B800h
        mov     ES,AX
        ; Помножити номер рядка на довжину рядка в байтах
        mov     AX,[ScreenString]
        mov     DX,160
        mul     DX
        ; Додати до отриманого добутку номер
        ; колонки (двічі)
        add     AX,[ScreenColumn]
        add     AX,[ScreenColumn]
        ; Переписати результат в індексний регістр
        mov     DI,AX
        pop     AX

; Використовувати колір символів, заданий за замовчуванням 
        mov     AH,[TextColorAndBackground]
; Вивести старший розряд числа 
        push    AX
        ; Виділити старший розряд
        shr     AL,4
        ; Перетворити старший розряд в код ASCII
        add     AL,'0'
        cmp     AL,'9'
        jbe     @@M0
        add     AL,'A'-'9'- 1
        ; Вивести розряд числа на екран
@@M0:   stosw
        pop     AX
; Вивести молодший розряд числа
        ; Виділити молодший розряд числа
        and     AL,0FH
        ; Перетворити молодший розряд в код ASCII
        add     AL,'0'
        cmp     AL,'9'
        jbe     @@M1
        add     AL,'A'-'9'- 1
        ; Вивести розряд числа на екран
@@M1:   stosw

; Підготовка для виводу наступних байтів
        ; Перевести поточну позицію на 2 символи ліворуч
        add     [ScreenColumn],2
        ; Перевірити перетин правої границі екрана 
        cmp     [ScreenColumn],80
        jb      @@End
        ; Якщо досягнута права границя екрана -
        ; перейти на наступну строку
        sub     [ScreenColumn],80
        inc     [ScreenString]
@@End:  pop     ES
        pop     DS
        popa
        ret
ENDP ShowByteHexCode


;*****************************************************
;*         Вивід 16-розрядного слова на екран        *
;*              в шістнадцятирічному коді            *
;* Параметри:                                        *
;* AX - число, яке буде виведено на екран.           *
;* Номер рядка передається через глобальну           *
;* змінну ScreenString, номер стовпчика - через      *
;* змінну ScreenColumn, колір тексту визначається    *
;* глобальною змінною TextColorAndBackground.        *
;*****************************************************
PROC ShowHexWord NEAR
        xchg    AL,AH
        call    ShowByteHexCode
        xchg    AL,AH
        call    ShowByteHexCode
        ret
ENDP ShowHexWord


;*****************************************************
;*         Вивід 32-розрядного слова на екран        *
;*              в шіснадцятирічному коді             *
;* Параметри:                                        *
;* EAX - число, яке буде виведено на екран.          *
;* Номер рядка передається через глобальну           *
;* змінну ScreenString, номер стовпчика - через      *
;* змінну ScreenColumn, колір тексту визначається    *
;* глобальною змінною TextColorAndBackground.        *
;*****************************************************
PROC ShowHexDWord NEAR
        rol     EAX,8
        call    ShowByteHexCode
        rol     EAX,8
        call    ShowByteHexCode
        rol     EAX,8
        call    ShowByteHexCode
        rol     EAX,8
        call    ShowByteHexCode
        ret
ENDP ShowHexDWord


;**************************************************
;*      Вивід байта на екран в двійковому коді    *
;* Підпрограма виводить вміст регістру AL         *
;* в двійковому коді в задану позицію екрана.     *
;* Координати позиції передаються через глобальні *
;* змінні ScreenString і ScreenColumn. Після      *
;* виконання операції виводу відбувається автома- *
;* тичне збільшення значень цих змінних.          *
;**************************************************
PROC ShowByteBinCode near
        pusha
        push    DS
        push    ES
        ; Копіюємо відображуваний байт в BL
        mov     BL,AL
        mov     AX,DGROUP
        mov     DS,AX
        cld
        ; Завантажити адресу "текстової" відеопам'яті в ES
        mov     AX,0B800h
        mov     ES,AX
        ; Помножити номер рядка на довжину рядка в байтах
        mov     AX,[ScreenString]
        mov     DX,160
        mul     DX
        ; Додати двічі номер колонки
        add     AX,[ScreenColumn]
        add     AX,[ScreenColumn]
        ; Переписати результат в індексний регістр
        mov     DI,AX

; Відобразити розряди числа (починаючи зі старшого)
        mov     AH,[TextColorAndBackground]
        mov     CX,8   ;лічильник розрядів
@@L0:   mov     AL,'0'
        ; Виділити черговий розряд числа 
        rol     BL,1
        jnc     @@L1
        mov     AL,'1'
        ; Вивести розряд числа на екран
@@L1:   stosw
        loop    @@L0

; Підготовка для виводу наступних байтів
        ; Перевести поточну позицію на 8 символів ліворуч
        add     [ScreenColumn],8
        ; Перевірити перетин правої границі екрана
        cmp     [ScreenColumn],80
        jb      @@End
        ; Якщо досягнута права границя екрана - 
        ; перейти на наступний рядок
        sub     [ScreenColumn],80
        inc     [ScreenString]
; Кінець підпрограми
@@End:  pop     ES
        pop     DS
        popa
        ret
ENDP ShowByteBinCode


;*******************************************************
;* Вивід 16-розрядного числа на екран в двійковому коді*
;* Параметри:                                          *
;* AX - число, яке буде виведено на екран.             *
;* Номер рядка передається через глобальну             *
;* змінну ScreenString, номер стовпчика - через        *
;* змінну ScreenColumn, колір тексту визначається      *
;* глобальною змінною TextColorAndBackground.          *
;*******************************************************
PROC ShowBinWord NEAR
        rol     AX,8
        call    ShowByteBinCode
        inc     [ScreenColumn]
        rol     AX,8
        call    ShowByteBinCode
        ret
ENDP ShowBinWord


;*******************************************************
;* Вивід 32-розрядного числа на екран в двійковому коді*
;* Параметри:                                          *
;* EAX - число, яке буде виведено на екран.            *
;* Номер рядка передається через глобальну             *
;* змінну ScreenString, номер стовпчика - через        *
;* змінну ScreenColumn, колір тексту визначається      *
;* глобальною змінною TextColorAndBackground.          *
;*******************************************************
PROC ShowBinDWord NEAR
        rol     EAX,8
        call    ShowByteBinCode
        inc     [ScreenColumn]
        rol     EAX,8
        call    ShowByteBinCode
        inc     [ScreenColumn]
        rol     EAX,8
        call    ShowByteBinCode
        inc     [ScreenColumn]
        rol     EAX,8
        call    ShowByteBinCode
        ret
ENDP ShowBinDWord


;*****************************************************
;*      Вивід текстової строки на екран              *
;* Всі параметри передаються через одну структуру:   *
;* перший байт - номер початкового рядка (0-24);     *
;* другий байт - номер початкової колонки (0-79);    *
;* далі йде рядок, обмежений нулем.                  *
;* Адреса структури передається через регістри DS:SI.*
;* тичне збільшення значень цих змінних.             *
;*****************************************************                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ****************
PROC ShowString near
        push    AX
        push    BX
        push    DI
        push    ES
; Настроїти регістр ES на глобальний сегмент даних
        mov     AX,DGROUP
        mov     ES,AX
; Запам'ятати колір текста в BL
        mov     BL,[ES:TextColorAndBackground]
; Настроїти регістр ES на відеопам'ять
        mov     AX,0B800h
        mov     ES,AX    
        cld
; Обчислити адресу для рядка у відеопам'яті
        ; Завантажити номер рядка екрана в AL і
        ; помножити його на довжину рядка в байтах
        lodsb
        ; Перевірка: номер рядка не повинен перевищувати
        ; межу нижньої границі екрана 
        cmp     AL,24  
        ja      @@Error
        mov     AH,160
        mul     AH
        ; Переписати результат в індексний регістр DI
        mov     DI,AX
        ; Завантажити номер стовпчика і двічі
        ; додати його до DI
        lodsb
        cmp     AL,79   ;номер колонки не повинен
        ja      @@Error ;перевищувати ширину екрана 
        mov     BH,AL   ;запам'ятати номер колонки
        xor     AH,AH   ;обнулити AH
        add     DI,AX
        add     DI,AX
        ; Завантажити атрибут кольору в AH
        mov     AH,BL
@@L1:   ; Завантажити черговий символ рядка в AL
        lodsb
        ; Перевірка на 0 (на кінець рядка)
        and     AL,AL  
        jz      @@L2
        ; Перевірити номер колонки символу
        cmp     BH,79
        ja      @@Error ;порушена права границя екрана
        ; Вивести символ на екран
        stosw
        inc     BH      ;збільшити номер колонки
        jmp     @@L1
@@L2:   pop     ES
        pop     DI
        pop     BX
        pop     AX
        ret
@@Error: ;Негайний вихід в DOS через помилку
        mov     AH,4Ch
        int     21h
ENDP ShowString


;******************************************************
;*  Вивід текстового рядка заданого кольору на екран  *
;* Всі параметри передаються через одну структуру:    *
;* перший байт - атрибут кольору і фону для рядка;    *
;* другий байт - номер початкового рядка (0-24);      *
;* третій байт - номер початкової колонки (0-79);     *
;* далі йде рядок, обмежений нулем.                   *
;* Адреса структури передається через регістри DS:SI. *
;******************************************************
PROC ShowColorString near
        push    AX
        ; Запам'ятати колір, що використовується за замовчуванням
        mov     AL,[TextColorAndBackground]
        push    AX
        ; Встановити колір рядка
        cld
        lodsb
        mov     [TextColorAndBackground],AL
        ; Використати функцію ShowString
        call    ShowString
        ; Відновити колір, що використовується за замовчуванням
        pop     AX
        mov     [TextColorAndBackground],AL
        pop     AX
        ret
ENDP ShowColorString


;*********************************
;*  Всановити позицію курсору    *
;* Вхідні параметри:             *
;* ScreenString - номер рядка    *
;* ScreenColumn - номер стовпчика*
;*********************************
PROC SetCursorPosition NEAR
        pusha
; Обчислення лінійної адреси курсору 
        mov     AX,[ScreenString]
        mov     BX,80
        mul     BX
        add     AX,[ScreenColumn]
        mov     BL,AL ;запам'ятати молдший байт
; Прямий вивід позиції курсору
; в регістри відеоконтролера 
        mov     DX,3D4h
        ; Вивести старший байт адреси курсору 
        mov     AL,0Eh
        out     DX,AX  
        ; Вивести молодший байт адреси курсору 
        inc     AL
        mov     AH,BL
        out     DX,AX  
        popa
        ret
ENDP SetCursorPosition


;*********************************************
;*       Прийняти символ з клавіатури        *
;* Процедура здійснює введення символу з     *
;* допомогою функції 00h переривання Int16h. *
;* Для "текстових" керуючих клавіш замість   *
;* скан-кодів використовуються ASCII-коди.   *
;* Вхідних параметрів немає.                 *
;* Функція повертає:                         *
;* AL - код символу;                         *
;* AH - керуючий код, якщо в AL нуль.        *
;*********************************************
PROC GetChar NEAR
        mov     AX,0
        int     16h
        and     AL,AL
        jnz     @@Get1
        ret     ;(в AL - нуль, в AH - керуючий код)
@@Get1: cmp     AL,32
        jnb     @@Get2
        ; Переписати в AH керуючий код
        xchg    AL,AH 
        mov     AL,0
        ret     ;(в AL - нуль, в AH - керуючий код)
@@Get2: mov     AH,0
        ret     ;(в AL - код літери, в AH - нуль)
ENDP GetChar


;*************************************************
;*        Прийняти символ з клавіатури,          *
;*            якщо він є в буфері                *
;* Процедура перевіряє наявність символу в буфері*
;* клавіатури і зчитує його, якщо він є.         *
;* Вхідних параметрів немає.                     *
;* Функція повертає:                             *
;* AL - код символа;                             *
;* AH - керуючий код, якщо в AL нуль.            *
;* Якщо в AL і AH нулі - натискань не було.      *
;*************************************************
PROC WaitChar NEAR
; Перевірити наявність символу в буфері клавіатури
        mov     AH,1
        int     16h
        jz      @@NoInput
; Прийняти символ від клавіатури
        mov     AX,0
        int     16h
        and     AL,AL
        jnz     @@GET1
        ret     ;в AL - нуль, в AH - керуючий код
@@GET1: cmp     AL,32
        jnb     @@GET2
        mov     AH,AL ;переписати в AH керуючий код
        mov     AL,0
        ret     ;в AL - нуль, в AH - керуючий код
@@GET2: mov     AH,0
        ret     ;в AL - код літери, в AH - нуль
@@NoInput:
        xor     AX,AX
        ret     ;в AL і AH - нулі
ENDP WaitChar


;*************************************
;* Очистка екрана в текстовому режимі*
;*  (процедура параметрів не має)    *
;*************************************
PROC ClearScreen NEAR
        pusha
        push    ES
; Настроїти ES:DI на "текстову" область відеопам'яті 
        mov     AX,0B800h 
        mov     ES,AX     
        cld
        mov     DI,0
; Вивести 2000 "порожніх" символів (ASCII-код 0) з
; атрибутом "білий колір, чорний фон"
        mov     CX,2000
        mov     AX,0F00H
        rep     stosw
        pop     ES
        popa
        ret
ENDP ClearScreen


;*****************************************************
;* Подача звукового сигналу через убудований динамік *
;*          (процедура параметрів не має)            *
;*****************************************************
PROC Beep NEAR
        push    AX
        push    DX
; Послати на термінал код "дзвінок" (07h)
        mov     AH,2
        mov     DL,7
        int     21h
        pop     DX
        pop     AX
        ret
ENDP Beep
ENDS
