;                     ЛИСТИНГ 2.2
;      Процедуры ввода/вывода общего назначения
;       для работы в цветном текстовом режиме
;
; Автор текста программы Кулаков Владимир Геннадьевич.
; Файл lst_2_02.inc, 10.03.2000.

DATASEG
; Цвет и фон выводимого текста (по умолчанию установим
; вывод белого текста по черному фону)
TextColorAndBackground DB 0Fh
; Начальная позиция для вывода текстовой строки на экран
ScreenString DW ?
ScreenColumn DW ?
ENDS

CODESEG
;*******************************************************
;*    ВЫВОД БАЙТА НА ЭКРАН В ШЕСТНАДЦАТЕРИЧНОМ КОДЕ    *
;* Подпрограмма выводит содержимое регистра AL         *
;* в шестнадцатеричном коде в заданную позицию экрана. *
;* Координаты позиции передаются через глобальные      *
;* переменные ScreenString и ScreenColumn. После       *
;* выполнения операции вывода происходит автомати-     *
;* ческое приращение значений этих переменных.         *
;*******************************************************
PROC ShowByteHexCode near
        pusha
        push    DS
        push    ES
        ; Настроить DS на глобальный сегмент данных
        mov     DI,DGROUP
        mov     DS,DI
        ; Настроить строковые команды процессора на
        ; автоинкрементный режим (движение "вперед")
        cld

; Настроить пару ES:DI для прямого вывода в видеопамять
        push    AX
        ; Загрузить адрес сегмента видеоданных в ES
        mov     AX,0B800h
        mov     ES,AX
        ; Умножить номер строки на длину строки в байтах
        mov     AX,[ScreenString]
        mov     DX,160
        mul     DX
        ; Прибавить к полученному произведению номер
        ; колонки (дважды)
        add     AX,[ScreenColumn]
        add     AX,[ScreenColumn]
        ; Переписать результат в индексный регистр
        mov     DI,AX
        pop     AX

; Использовать цвет символов, заданный по умолчанию
        mov     AH,[TextColorAndBackground]
; Вывести старший разряд числа 
        push    AX
        ; Выделить старший разряд
        shr     AL,4
        ; Преобразовать старший разряд в код ASCII
        add     AL,'0'
        cmp     AL,'9'
        jbe     @@M0
        add     AL,'A'-'9'- 1
        ; Вывести разряд числа на экран
@@M0:   stosw
        pop     AX
; Вывести младший разряд числа 
        ; Выделить младший разряд числа
        and     AL,0FH
        ; Преобразовать младший разряд в код ASCII
        add     AL,'0'
        cmp     AL,'9'
        jbe     @@M1
        add     AL,'A'-'9'- 1
        ; Вывести разряд числа на экран
@@M1:   stosw

; Подготовка для вывода следующих байтов
        ; Перевести текущую позицию на 2 символа влево
        add     [ScreenColumn],2
        ; Проверить пересечение правой границы экрана
        cmp     [ScreenColumn],80
        jb      @@End
        ; Если достигнута правая граница экрана -
        ; перейти на следующую строку
        sub     [ScreenColumn],80
        inc     [ScreenString]
@@End:  pop     ES
        pop     DS
        popa
        ret
ENDP ShowByteHexCode


;*****************************************************
;*         ВЫВОД 16-РАЗРЯДНОГО СЛОВА НА ЭКРАН        *
;*              В ШЕСТНАДЦАТЕРИЧНОМ КОДЕ             *
;* Параметры:                                        *
;* AX - число, которое будет выведено на экран.      *
;* Номер строки передается через глобальную          *
;* переменную ScreenString, номер столбца - через    *
;* переменную ScreenColumn, цвет текста определяется *
;* глобальной переменой TextColorAndBackground.      *
;*****************************************************
PROC ShowHexWord NEAR
        xchg    AL,AH
        call    ShowByteHexCode
        xchg    AL,AH
        call    ShowByteHexCode
        ret
ENDP ShowHexWord


;*****************************************************
;*         ВЫВОД 32-РАЗРЯДНОГО СЛОВА НА ЭКРАН        *
;*              В ШЕСТНАДЦАТЕРИЧНОМ КОДЕ             *
;* Параметры:                                        *
;* EAX - число, которое будет выведено на экран.     *
;* Номер строки передается через глобальную          *
;* переменную ScreenString, номер столбца - через    *
;* переменную ScreenColumn, цвет текста определяется *
;* глобальной переменой TextColorAndBackground.      *
;*****************************************************
PROC ShowHexDWord NEAR
        rol     EAX,8
        call    ShowByteHexCode
        rol     EAX,8
        call    ShowByteHexCode
        rol     EAX,8
        call    ShowByteHexCode
        rol     EAX,8
        call    ShowByteHexCode
        ret
ENDP ShowHexDWord


;**************************************************
;*      ВЫВОД БАЙТА НА ЭКРАН В ДВОИЧНОМ КОДЕ      *
;* Подпрограмма выводит содержимое регистра AL    *
;* в двоичном коде в указанную позицию экрана.    *
;* Координаты позиции передаются через глобальные *
;* переменные ScreenString и ScreenColumn. После  *
;* выполнения операции вывода происходит автома-  *
;* тическое приращение значений этих переменных.  *
;**************************************************
PROC ShowByteBinCode near
        pusha
        push    DS
        push    ES
        ; Копируем отображаемый байт в BL
        mov     BL,AL
        mov     AX,DGROUP
        mov     DS,AX
        cld
        ; Загрузить адрес "текстовой" видеопамяти в ES
        mov     AX,0B800h
        mov     ES,AX
        ; Умножить номер строки на длину строки в байтах
        mov     AX,[ScreenString]
        mov     DX,160
        mul     DX
        ; Прибавить дважды номер колонки
        add     AX,[ScreenColumn]
        add     AX,[ScreenColumn]
        ; Переписать результат в индексный регистр
        mov     DI,AX

; Отобразить разряды числа (начиная со старшего)
        mov     AH,[TextColorAndBackground]
        mov     CX,8   ;счетчик разрядов
@@L0:   mov     AL,'0'
        ; Выделить очередной разряд числа
        rol     BL,1
        jnc     @@L1
        mov     AL,'1'
        ; Вывести разряд числа на экран
@@L1:   stosw
        loop    @@L0

; Подготовка для вывода следующих байтов
        ; Перевести текущую позицию на 8 символов влево
        add     [ScreenColumn],8
        ; Проверить пересечение правой границы экрана
        cmp     [ScreenColumn],80
        jb      @@End
        ; Если достигнута правая граница экрана - 
        ; перейти на следующую строку
        sub     [ScreenColumn],80
        inc     [ScreenString]
; Конец подпрограммы
@@End:  pop     ES
        pop     DS
        popa
        ret
ENDP ShowByteBinCode


;******************************************************
;* ВЫВОД 16-РАЗРЯДНОГО СЛОВА НА ЭКРАН В ДВОИЧНОМ КОДЕ *
;* Параметры:                                         *
;* AX - число, которое будет выведено на экран.       *
;* Номер строки передается через глобальную           *
;* переменную ScreenString, номер столбца - через     *
;* переменную ScreenColumn, цвет текста определяется  *
;* глобальной переменой TextColorAndBackground.       *
;******************************************************
PROC ShowBinWord NEAR
        rol     AX,8
        call    ShowByteBinCode
        inc     [ScreenColumn]
        rol     AX,8
        call    ShowByteBinCode
        ret
ENDP ShowBinWord

PROC ShowBinDWord NEAR
        rol     EAX,8
        call    ShowByteBinCode
        inc     [ScreenColumn]
        rol     EAX,8
        call    ShowByteBinCode
        inc     [ScreenColumn]
        rol     EAX,8
        call    ShowByteBinCode
        inc     [ScreenColumn]
ENDP ShowBinDWord

PROC ShowString near
        push    AX
        push    BX
        push    DI
        push    ES
; Настраить регистр ES на глобальный сегмент данных
        mov     AX,DGROUP
        mov     ES,AX
; Запоминить цвет текста в BL
        mov     BL,[ES:TextColorAndBackground]
; Настраить регистр ES на видеопамять
        mov     AX,0B800h
        mov     ES,AX    
        cld
; Вычислить адрес для строки в видеопамяти
        ; Загрузить номер строки экрана в AL и
        ; умножить его на длину строки в байтах
        lodsb
        ; Проверка: номер строки не должен превышать
        ; предел нижней границы экрана
        cmp     AL,24  
        ja      @@Error
        mov     AH,160
        mul     AH
        ; Переписать результат в индексный регистр DI
        mov     DI,AX
        ; Загрузить номер столбца и дважды
        ; прибавить его к DI
        lodsb
        cmp     AL,79   ;номер колонки не должен
        ja      @@Error ;превышить ширины экрана
        mov     BH,AL   ;запомнить номер колонки
        xor     AH,AH   ;обнулить AH
        add     DI,AX
        add     DI,AX
        ; Загрузить атрибут цвета в AH
        mov     AH,BL
@@L1:   ; Загрузить очередной символ строки в AL
        lodsb
        ; Проверка на 0 (на конец строки)
        and     AL,AL  
        jz      @@L2
        ; Проверить номер колонки символа
        cmp     BH,79
        ja      @@Error ;нарушена правая граница экрана
        ; Вывести символ на экран
        stosw
        inc     BH      ;увеличить номер колонки
        jmp     @@L1
@@L2:   pop     ES
        pop     DI
        pop     BX
        pop     AX
        ret
@@Error: ;Немедленный выход в DOS по ошибке
        mov     AH,4Ch
        int     21h
ENDP ShowString


;*****************************************************
;*  ВЫВОД ТЕКСТОВОЙ СТРОКИ ЗАДАННОГО ЦВЕТА НА ЭКРАН  *
;* Все параметры передаются через одну структуру:    *
;* первый байт - атрибут цвета и фона для строки;    *
;* второй байт - номер начальной строкиа (0-24);     *
;* третий байт - номер начальной колонки (0-79);     *
;* далее идет строка, ограниченная нулем.            *
;* Адрес структуры передается через регистры DS:SI.  *
;*****************************************************
PROC ShowColorString near
        push    AX
        ; Запомнить цвет, используемый по умолчанию
        mov     AL,[TextColorAndBackground]
        push    AX
        ; Установить цвет строки
        cld
        lodsb
        mov     [TextColorAndBackground],AL
        ; Использовать функцию ShowString
        call    ShowString
        ; Восстановить цвет, используемый по умолчанию
        pop     AX
        mov     [TextColorAndBackground],AL
        pop     AX
        ret
ENDP ShowColorString


;********************************
;*  УСТАНОВИТЬ ПОЗИЦИЮ КУРСОРА  *
;* Входные параметры:           *
;* ScreenString - номер строки  *
;* ScreenColumn - номер столбца *
;********************************
PROC SetCursorPosition NEAR
        pusha
; Вычисление линейного адреса курсора
        mov     AX,[ScreenString]
        mov     BX,80
        mul     BX
        add     AX,[ScreenColumn]
        mov     BL,AL ;запомнить младший байт
; Прямой вывод позиции курсора
; в регистры видеоконтроллера
        mov     DX,3D4h
        ; Вывести старший байт адреса курсора
        mov     AL,0Eh
        out     DX,AX  
        ; Вывести младший байт адреса курсора
        inc     AL
        mov     AH,BL
        out     DX,AX  
        popa
        ret
ENDP SetCursorPosition


;*********************************************
;*       ПРИНЯТЬ СИМВОЛ ОТ КЛАВИАТУРЫ        *
;* Процедура осуществляет ввод символа с     *
;* помощью функции 00h прерывания Int16h.    *
;* Для "текстовых" управляющих клавиш вместо *
;* скан-кодов используются ASCII-коды.       *
;* Входных параметров нет.                   *
;* Функция возвращает:                       *
;* AL - код символа;                         *
;* AH - управляющий код, если в AL ноль.     *
;*********************************************
PROC GetChar NEAR
        mov     AX,0
        int     16h
        and     AL,AL
        jnz     @@Get1
        ret     ;(в AL - ноль, в AH - управляющий код)
@@Get1: cmp     AL,32
        jnb     @@Get2
        ; Переписать в AH управляющий код
        xchg    AL,AH 
        mov     AL,0
        ret     ;(в AL - ноль, в AH - управляющий код)
@@Get2: mov     AH,0
        ret     ;(в AL - код буквы, в AH - ноль)
ENDP GetChar


;************************************************
;*        ПРИНЯТЬ СИМВОЛ ОТ КЛАВИАТУРЫ,         *
;*            ЕСЛИ ОН ЕСТЬ В БУФЕРЕ             *
;* Процедура проверяет наличие символа в буфере *
;* клавиатуры и считывает его, если он есть.    *
;* Входных параметров нет.                      *
;* Функция возвращает:                          *
;* AL - код символа;                            *
;* AH - управляющий код, если в AL ноль.        *
;* Если в AL и AH нули - нажатий не было.       *
;************************************************
PROC WaitChar NEAR
; Проверить наличие символа в буфере клавиатуры
        mov     AH,1
        int     16h
        jz      @@NoInput
; Принять символ от клавиатуры
        mov     AX,0
        int     16h
        and     AL,AL
        jnz     @@GET1
        ret     ;в AL - ноль, в AH - управляющий код
@@GET1: cmp     AL,32
        jnb     @@GET2
        mov     AH,AL ;переписать в AH управляющий код
        mov     AL,0
        ret     ;в AL - ноль, в AH - управляющий код
@@GET2: mov     AH,0
        ret     ;в AL - код буквы, в AH - ноль
@@NoInput:
        xor     AX,AX
        ret     ;в AL и AH - нули
ENDP WaitChar


;*************************************
;* ОЧИСТКА ЭКРАНА В ТЕКСТОВОМ РЕЖИМЕ *
;*  (процедура параметров не имеет)  *
;*************************************
PROC ClearScreen NEAR
        pusha
        push    ES
; Настроить ES:DI на "текстовую" область видеопамяти
        mov     AX,0B800h 
        mov     ES,AX     
        cld
        mov     DI,0
; Вывести 2000 "пустых" символов (ASCII-код 0) с
; атрибутом "белый цвет, черный фон"
        mov     CX,2000
        mov     AX,0F00H
        rep     stosw
        pop     ES
        popa
        ret
ENDP ClearScreen


;*****************************************************
;* ПОДАЧА ЗВУКОВОГО СИГНАЛА ЧЕРЕЗ ВСТРОЕННЫЙ ДИНАМИК *
;*          (процедура параметров не имеет)          *
;*****************************************************
PROC Beep NEAR
        push    AX
        push    DX
; Послать на терминал код "звонок" (07h)
        mov     AH,2
        mov     DL,7
        int     21h
        pop     DX
        pop     AX
        ret
ENDP Beep
ENDS
